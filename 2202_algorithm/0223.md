# 0223 Stack2

후위식 연산:

​	토큰 : 피연산자 push

​	연산자 pop

​	push(b 연산 a)

​	print(pop)

1. 수식의 각 연산자에 대해 우선순위에 따라 괄호를 사용하여 다시 표현
   1. 토큰이 피연산자이면 토큰을 출력
   2. 토큰 피연산자이면 토큰을 출력
   3. 토큰이 연산자일 때
      - 우선순위 높을때 : stack에 푸쉬
      - 우선순이 안높을때 : stack에서 pop한 후 push - 우선순위가 낮은것은 아래에 있음
      - top에 연산자가 없으면 : stack에 푸쉬
   4. 토큰이 오른쪽 괄호일때
      - stack top에 왼쪽 괄호가 올때까지 stack에 pop연산 수행
      - pop한 연산자 출력
      - 왼쪽 괄호 만나면 pop만 하고 출력 안함
   5. 1부터 다시 반복
   6. stack에 남아있는 연산자를 모두 pop하여 출력
2. 각 연산자를 그에 대응하는 오른쪽 괄호 뒤로 이동
3. 괄호 제거





## DFS (깊이우선탐색)

- 가장 마지막에 만났던 갈림길의 정점으로 되돌아서서 다시 깊이 우선 탐색을 하므로

  후입선출 구조의 스택 사용

1) 시작 정점 v를 결정하여 방문한다.

2) 정점 v에 인접한 정점 중에서

   1) 방문하지 않은 정점 w가 있으면 정점 v를 스택에 push하고 정점 w를 방문한다.

      그리고 w를 v로 하여 다시 2를 반복한다.

   2. 방문하지 않은 정점이 없으면 탐색 방향을 바꾸기 위해 스택을 pop하여 받은

      가장 마지막 방문 정점을 v로 하여 다시 2)를 반복한다

   3. 스택이 공백이 될때까지 2를 반복한다.

      

## 백트래킹

- 미로찾기 예시
  1. 갈 곳을 오른쪽 아래 왼쪽 위 (시계방향) 이라고 정해둠
  2. 계속 감 (push)
  3. 만약 더이상 갈 곳이 없으면 (pop)
     - 한칸 뒤로 갔을 때 네 방향을 다 보고 뒤로 가는건지?
     - 아니면 갈 곳이 있으면 그대로 뒤로 가는건지?



### DFS 와 백트래킹 차이

DFS는 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기 탐색

재귀의 깊이우선탐색을 만들어 놓고 백트래킹을 하면 좋음(?)

```
    ``res.append(x)
    ``else``:
      ``while` `stack and icp[stack[-1]] >= icp[x]:
        ``res.append(stack.pop())
      ``stack.append(x)
  ``while` `stack:
    ``res.append(stack.pop())
```

#### 연습문제 : 부분집합

기본형

```python
def f(i, N): # i 부분집합에 포함될지 결정할 원소의 인덱스, N: 전체 원소개수
    if i == N: # 한개의 부분집합 완성
        print(bit)

    else:
        bit[i] = 1
        f(i+1, N)
        bit[i] = 0
        f(i+1, N)
a = [1,2,3]
bit = [0,0,0]
f(0,3)
'''
[1, 1, 1] 
[1, 1, 0] 
[1, 0, 1] 
[1, 0, 0] 
[0, 1, 1] 
[0, 1, 0]  
[0, 0, 1]
[0, 0, 0]
'''
```

```python
def f(i, N): # i 부분집합에 포함될지 결정할 원소의 인덱스, N: 전체 원소개수
    if i == N: # 한개의 부분집합 완성
        print(bit, end=' ')
        for j in range(N):
            if bit[j]:
                print(a[j], end=' ')
        print()
    else:
        bit[i] = 1
        f(i+1, N)
        bit[i] = 0
        f(i+1, N)
a = [1,2,3]
bit = [0,0,0]
f(0,3)
''' 원소 잘 나오는지
[1, 1, 1] 1 2 3 
[1, 1, 0] 1 2 
[1, 0, 1] 1 3 
[1, 0, 0] 1 
[0, 1, 1] 2 3 
[0, 1, 0] 2 
[0, 0, 1] 3 
[0, 0, 0] 
'''
```

```python
def f(i, N, K): # i 부분집합에 포함될지 결정할 원소의 인덱스, N: 전체 원소개수 K: 찾는 합
    if i == N: # 한개의 부분집합 완성
       #print(bit, end=' ')
        s = 0
        for j in range(N):
            if bit[j]:
                s += a[j]
        #찾는 합과 합이 같을 때
        if s == K:
            for j in range(N):
                if bit[j]:
                    print(a[j], end=' ')
            print()
    else:
        # 가지치기
        bit[i] = 1  	# 1을 넣는 경우
        f(i+1, N, K)
        bit[i] = 0 		# 0을 넣는 경우
        f(i+1, N, K)

a = [1,2,3]
N = len(a)
bit = [0,0,0]
f(0, N, 3)
'''
1 2 
3 
'''
```





## 순열

[123, 132, 213, 231, 312, 321]

- 자리바꾸기
- 쓴 숫자 제외하기



## 퀵정렬

- 주어진 배열을 두 개로 분할하고, 각각 정렬

- 합병정렬 vs 퀵정렬

  - 합병정렬은 그냥 두 부분으로 나누는 반면,

    퀵정렬은 기준 아이템 중심으로 이보다 작은것은 왼쪽, 큰 것은 오른쪽에 위치한다.

  - 합병정렬은 정렬 후 합병이란 단계가 필요한 반면,

    퀵정렬은 필요하지 않다.

