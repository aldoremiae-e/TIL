# :book: 분할정복 알고리즘

> 주어진 문제를 보다 작은 문제로 나누어 해결하는 알고리즘

[TOC]

## 1. 이진 검색

> 정렬된 데이터 리스트에서 목표값 또는 목표값이 있는 위치를 빠른 시간에 찾는 분할 정복 알고리즘

정렬된 데이터 배열 A[] 에서 목표값 target 을 찾을 때

1. 인덱스 중앙값 mid 을 구한다.

   첫번째 인덱스 low , 마지막 인덱스 high

2. A[mid] 와 target을 비교

   1. 같으면 찾은 것
   2. A[mid] < target 이면 low = mid + 1
   3. A[mid] > target 이면 high = mid - 1

3. 탐색구간이 남아있고 목표값을 찾지 못하면 1, 2 프로세스 반복



```python
# 루프
while low <= high:
    mid = (low+high) / 2
    if A[mid] == target:
            return mid
    if A[mid] < target:
        low = mid + 1
    elif A[mid] > target:
        high = mid - 1
return -1

# 재귀
binarySearchRecur(A[],low,high,target):
	if low > high:
    	return -1
	mid = (low + high) / 2
	if A[mid] == target:
    	return mid
	if A[mid] < target:
    	return binarySearchRecur(A,mid+1,high,target)
    else:
        return binarySearchRecur(A,low,mid-1,target)
```



### :pencil: 문제

- [정올 3517](http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&wr_id=2857&sca=30)
  
  ```python
  N = int(input())
  arr = list(map(int, input().split()))
  Q = int(input())
  bi = list(map(int,input().split()))
  
  # bi를 돌면서 arr를 q번 돌꺼야
  for target in bi:
      low = 0
      high = N
      ans = -1
      while low <= high:
          mid = (low+high) // 2
          if arr[mid] == target:
              ans = mid
              break
          if arr[mid] > target:
              high = mid - 1
          elif arr[mid] < target:
              low = mid + 1
      print(ans, end=' ')
  ```
  

- [정올 1240](http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&code=1240&sca=3010)

  ```python
  N = int(input())
  n = int(N ** 0.5)
  print(n)
  ```

  

## 2. 퀵정렬

## 3. 합병정렬





