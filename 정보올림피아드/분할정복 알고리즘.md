# :book: 분할정복 알고리즘

> 주어진 문제를 보다 작은 문제로 나누어 해결하는 알고리즘

[TOC]

## 1. 이진 검색

> 정렬된 데이터 리스트에서 목표값 또는 목표값이 있는 위치를 빠른 시간에 찾는 분할 정복 알고리즘

정렬된 데이터 배열 A[] 에서 목표값 target 을 찾을 때

1. 인덱스 중앙값 mid 을 구한다.

   첫번째 인덱스 low , 마지막 인덱스 high

2. A[mid] 와 target을 비교

   1. 같으면 찾은 것
   2. A[mid] < target 이면 low = mid + 1
   3. A[mid] > target 이면 high = mid - 1

3. 탐색구간이 남아있고 목표값을 찾지 못하면 1, 2 프로세스 반복



```python
# 루프
while low <= high:
    mid = (low+high) / 2
    if A[mid] == target:
            return mid
    if A[mid] < target:
        low = mid + 1
    elif A[mid] > target:
        high = mid - 1
return -1

# 재귀
binarySearchRecur(A[],low,high,target):
	if low > high:
    	return -1
	mid = (low + high) / 2
	if A[mid] == target:
    	return mid
	if A[mid] < target:
    	return binarySearchRecur(A,mid+1,high,target)
    else:
        return binarySearchRecur(A,low,mid-1,target)
```



### :pencil: 문제

- [정올 3517](http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&wr_id=2857&sca=30)
  
  ```python
  N = int(input())
  arr = list(map(int, input().split()))
  Q = int(input())
  bi = list(map(int,input().split()))
  
  # bi를 돌면서 arr를 q번 돌꺼야
  for target in bi:
      low = 0
      high = N
      ans = -1
      while low <= high:
          mid = (low+high) // 2
          if arr[mid] == target:
              ans = mid
              break
          if arr[mid] > target:
              high = mid - 1
          elif arr[mid] < target:
              low = mid + 1
      print(ans, end=' ')
  ```
  
- [정올 1240](http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&code=1240&sca=3010)

  ```python
  N = int(input())
  n = int(N ** 0.5)
  print(n)
  ```

  

## 2. 퀵정렬

> 비교와 교환을 통하여 정렬하는 비교기분정렬 알고리즘

- 시간복잡도 : 평균 (N * logN) , 최악의 경우 N^2

1. low >= high라면 정렬된 것이다.
2. 분할 과정 : 
   1. 구간 내 임의의 원소를  pivot값으로 정한다. 여기서는 pivot = A[high] 로 한다.
   2. pivot 이하의 값들을 배열의 왼쪽에 pivot 이상의 값들을 오른쪽에 배치시킨다.
   3. pivot의 자리를 찾아준다.

### :pencil: 문제

- [정올_3518](http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&code=3518&sca=3010)

  ```python
  # 퀵소트
  
  def quick(A, low, high):
      if low >= high-1:
          return
      pivot = A[high-1]
      i = low
      for j in range(low, high):
          if A[j] < pivot:
              tmp = A[j]
              A[j] = A[i]
              A[i] = tmp
              i += 1
      tmp = A[i]
      A[i] = A[high-1]
      A[high-1] = tmp
      for k in A:
          print(k, end=' ')
      print()
      quick(A, low, i)
      quick(A, i+1, high)
  
  N = int(input())
  A = list(map(int, input().split()))
  quick(A, 0, len(A))
  ```

  

## 3. 합병정렬





