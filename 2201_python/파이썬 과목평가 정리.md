# 파이썬 과목평가 정리



## 파이썬 개발 환경

- Easy to learn : 다른 프로그래밍 언어보다 문법이 간단하여서 짧은 시간 내 터득 가능

- Expressive Language : 다양한 운영체제에서 실행가능하고, 다른 언어보다 간결하게 작성 가능

- 인터프리터 언어 : 컴파일 과정 없이 바로 실행 가능, 코드를 대화하듯 한 줄 쓰고 바로 확인 가능

  - 파이썬 기본 interpreter(IDLE) , jupyter
  - 스크립트 .py로 실행, IDE(pycharm) 혹은 Text Editor(VScode) 활용

- 객체지향프로그래밍 (OOP) : 파이썬은 객체 지향 언어이고, 모든 것이 객체로 구현되어 있음

  - 객체란 숫자,문자,클래스 등 '값'을 가진 모든 것

  

## 기초 문법

- Space Sensitive : 들여쓰기(4칸, tap키 한번)로 문장을 구분

- 변수 : 객체를 참조하기 위해 사용되는 이름

  - 같은 변수에 다른 객체를 참조할 수 있기 때문에, 즉 참조하는 객체가 변할 수 있으므로 변수

  - 객체 : 숫자, 문자, 클래스 등 값을 가진 모든 것

  - 저장(할당) : 할당 연산자 (=) 를 통해 할당(assignment)

    ```python
    # x : 변수의 식별자
    # 'ssafy' : 리터럴
    x = 'ssafy'
    type(x) # => str , 변수의 자료형(타입)
    id(x)	#=> 4645387184 , 메모리주소
    ```

    ```python
    x = y = 1004	# => 다른 변수에 같은 값을 동시에 할당 가능
    x, y = 1, 2 	# => 다른 변수에 다른 값을 동시에 할당 가능
    y, x = x, y
    print(x, y) # => 2, 1 (pythonic하게 숫자 바꾸기)
    ```

- 식별자 : 변수의 이름

  - 영문 알파벳, _ , 숫자로 구성

  - 첫글자에 숫자 올 수 X

  - 길이제한 x 대소문자 구별

  - 내장함수, 모듈의 이름으로 만들면 X

  - 아래 키워드는 예약어로 사용할 수 없음 (이미 정해져 있기 때문에)

    ![image-20220203212341264](C:/Users/bamxd/AppData/Roaming/Typora/typora-user-images/image-20220203212341264.png)

- input([]) : 사용자로부터 입력받는 내장함수 , 반환값 문자열의 형태로 반환



## 자료형

- 데이터 타입

  - 불린형

    - False 로 반환 되는 것들 :	0, 0.0, (), [], {}, '', None

    ```python
     bool([0]) # => 리스트 안에 0이 들어 있는 거니까 True
    ```

  - 수치형

    - 정수형 int , 오버플로우 발생X

      - 2진수 0bn , 8진수 0on , 16진수 0xn

    - 부동소수점형 float

      - floating point rounding error : 부동소수점에서 실수 연산 과정 발생 가능
        - 값 비교할 때 같지 않다고 뜸
        - 이럴 때는 import sys 혹은 import math.isclose() 를 사용

    - 복소수형 complex

      ```python
      a = 3 + 4j
      a.real # => 3.0
      a.imag # => 4.0
      ```

  - 문자열

    - 문자열은 불변(immutable)하고, 반복가능(iterable)하다

      - "문자열안에 '작은따옴표'는 이렇게 사용하는 것"
      - '문자열안에"큰따옴표"는 이렇게 사용하는 것'
      - ''' 삼중따옴표는 여러줄을 나눠 입력할 때 자주 사용 '''

    - escape sequence : \역슬레시 사용, 역슬레시를 표현하고싶다면 \\

    - 문자열을 변수를 활용하여 만들기

      ```python
      print('%s' %name)
      print('이름은{}, 성적은{}'.format(name,score))
      print(f'이름은{name}, 성적은{score}')
      ```

  - None : 값이 없음을 나타내는 타입

  

## 컨테이너

> 컨테이너랑 여러개의 값을 가지고 있는 객체로, 서로 다른 자료형을 저장할 수 있다

순서가 있는 데이터 (시퀀스형) **!= 데이터가 정렬되어 있다**

- 리스트[] : 순서가 있는 시퀀스로 인덱스 (0)번째부터 접근 가능

- 문자열 (불변형)

- 튜플() (불변형)  : 수정 불가능한 시퀀스로 인덱스 (0)번째부터 접근 가능

  ```python
  # 단일 항목일 경우 , 붙여주면 튜플됨
  a = 1,
  print(type(a))	# => 'tuple'
  ```

- 레인지(불변형) : range(n,m,s) , 숫자의 시퀀스를 나타내기 위해 사용

  ```python
  list(range(1, 3, -1))	# => []
  list(range(6, 1, 1))	# => []
  ```

  

순서가 없는 데이터 (비시퀀스형)

- 셋{1,2,3,1,2},set() : 중복없이 순서가 없는 자료형 , set을 사용하면 순서가 사라짐

- 딕셔너리{} : 순서없이 key-value 로 이루어진 자료형

  - key : immutable 만 가능 (string, tuple, range, float, int, boolean)
  - value : 다 가능
  - 빈 중괄호는 딕셔너리

  

## 연산자

- 사칙연산
  - divmod(나눌값,나누는값) : 몫, 나머지
- 논리연산자 단축평가
  - 결과가 확실한 경우 : 두번째값 안보고 첫번째 값 반환 
    - and 에서 첫번째값이 false 면 false : 첫번째 값 반환
    - or 에서 첫번째값이 true 면 true : 첫번째 값 반환



## 제어문

1. 조건문
2. 반복문



## 함수

> 함수를 사용해야 하는 이유 : 코드 중복을 방지하게 하기 위해서, 재사용이 용이하기 때문에

1. 기초

- 함수의 기본 구조 : 선언과 호출 / 입력 / 문서화 / 범위 / 결과값
- 선언 : def키워드를 활용
- 호출 : 함수명() 으로 호출 , () 안에는 파라미터

2. 결과값

- Void function : 명시적인 return 값이 없으면 None 반환
- Value returning function : 함수 실행 후 값 반환 후 함수가 바로 종료

- 주의 : return은 함수 안에서만 사용되는 키워드이고, print는 출력을 위해 사용되는 함수

3. 입력

- Parameter : 함수를 실행할 때, 내부에서 사용되는 식별자

- Argument : 함수를 호출할 때, 넣어주는 값 - parater를 통해 전달되는 값

  ```python
  def say(anything): # 파라미터 : 함수를 실행할 때 넣어줌, 함수 내부에서 식별자로 사용
      print(f'안녕{anything}')
  say('미애야')		# 아규먼트 : '미애야'
  ```

  ```python
  def add(x,y): # 첫번째 변수 x,  두번째 변수 y로 정했을 때
      return x+y
  
  #위치 
  print(add(1,2)) # 알아서 x = 1, y = 2 로 바인딩 # 위치 호출
  #키워드
  print(add(y=2,x=1)) # 근데 이건 y=2 , x=1 로 직접 적어줌 # 키워드 호출
  #위치와 키워드
  print(add(1,y=2)) 
  
  ##키워드와 위치 X : 키워드로 지정하는 순간 위치 의미 없어져서 에러가 뜸
  #print(add(x=1,2))
  ```

  - Positional Argument Packing/Unpacking 연산자(*) : 여러개의 Positional Argument 정의할 때

    `*args `(tuple) ` **kwargs`(dictionary)

4. 범위

   L:Local scope 함수 

   E : Enclose 특정 함수의 상위 함수

   G : Global 함수 밖의 변수, Import 모듈

   B : Built-in-scope : 파이썬 안에 내장되어 있는 함수

   ```python
   10, 1, 300
   10, 1, 3
   0, 1
   ```

5. 문서화

6. 응용

- map (function,iterable)

  - (데이터 타입 함수, 순회가능한 데이터 구조)

  ```python
  numbers = [1,2,3]
  result = map(str,numbers)
  print(result, type(result)) # => <map object at 0x10e2ca100> <class 'map'>
  list(result)				# => ['1','2','3'] 리스트 형변환을 통해 결과확인
  ```

  ```python
  # 두 개의 숫자를 입력받고 싶을 떄
  n, m = map(int,input().split())
  ```

- filter(function,iterable)

  ```python
  def odd(n):
      return n % 2
  numbers = [1,2,3]
  result = filter(odd,numbers)
  print(result, type(result)) # => <filter object at 0x10e4dfc10> <class 'filter'>
  list(result)				# => [1, 3]
  ```

- zip(*iterables)

  - 여러개의 iterables를 모아 튜플을 원소로 하는 zip 객체 반환

  ```python
  girls = ['jane','ashley']
  boys = ['justin','eric']
  pair = zip(girls,boys)
  print(pair,type(pair))		# => <zip objcet at 0x10e500c80> <class 'zip'>
  list(pair)					# => [('jane','justin'), ('ashley','eric')]
  ```

- lambda[parameter] : 표현식

  - 표현식을 계산한 결과값을 반환하는 함수
  - return 문을 가질 수 없음
  - 간편 조건문 외 조건문, 반복문 가질 수 없음
  - 함수를 정의하는 것보다 간편함
  - def 사용할 수 없을 떄 사용가능

  ```python
  triangle_area = lambda b,h : 0.5 * b * h
  triangle_area(5,6) # => 15.0
  ```

- 재귀함수 : 자기자신을 호출하는 함수



## 모듈과 패키지

1. 파이썬 표준 라이브러리

   - 패키지 설치는 bash,cmd환경에서 사용되는 명령어 : pip install 
   - 모듈을 만들때는 check.py로 만들기, 실행할 떄는 import 모듈
     - 혹은 from 모듈 import 함수

   - 패키지는 여러모듈과 하위 패키지로 구조화 됨

2. 가상환경

   - 가상환경을 통해 프로젝트별 독립적인 패키지를 관리할 수 있다.
   - $ python -m venv <폴더명> : 가상환경을 만들고 관리하는데 사용되는 모듈

3. 유용한 패키지와 모듈

4. 사용자 모듈과 패키지



## 데이터구조

1. 순서가 있는 데이터 구조

   - 문자열, 리스트, 튜플

   - 문자열 메소드

     - 문자열 조회/탐색 및 검증 메소드

       | 문법        | 문자열 조회/탐색 및 검증 메소드      |
       | :---------- | ------------------------------------ |
       | s.find(x)   | x의 첫번째 위치를 반환, 없으면 -1    |
       | s.index(x)  | x의 첫 번째 위치를 반환, 없으면 오류 |
       | s.isalpha() | 알파벳 문자 여부 *유니코드 상 Letter |
       | s.isupper() | 대문자 여부                          |
       | s.islower() | 소문자 여부                          |
       | s.istitle() | 타이틀 형식 여부                     |

       | 문법                        | 문자열 변경 메소드                                           |
       | --------------------------- | ------------------------------------------------------------ |
       | s.replace(old,new[,count])  | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환,<br /> 숫자쓰면 그 갯수만큼 바뀜 |
       | s.strip([chars])            | 공백이나 특정 문자를 제거                                    |
       | s.split([chars])            | 공백이나 특정 문자를 기준으로 분리                           |
       | 'separator'.join([iteable]) | 구분자로 itreable을 합쳐 문자열 반환                         |
       | s. title()                  | '나 공백 이후를 대문자로                                     |
       | s.upper()                   | 모두 대문자                                                  |
       | s.lower()                   | 모두 소문자                                                  |
       | s.swapcase()                | 대<->소문자 변경                                             |

   - 리스트 메소드

     | 문법                 | 리스트 메소드                                                |
     | -------------------- | ------------------------------------------------------------ |
     | L.append(x)          | 마지막에 항목 x 추가                                         |
     | L.insert(i,x)        | 인덱스 i에 항목 x 삽입                                       |
     | L.remove(x)          | 가장 왼쪽에 있는 항목 x를 제거, 항목 존재하지 않을 시 ValueError |
     | L.pop()              | 가장 오른쪽에 있는 항목 반환 후 제거                         |
     | L.pop(i)             | 인덱스 i에 있는 항목 반환 후 제거                            |
     | L.extend(m)          | += 같은 느낌, * [coffee]=>'coffee' 랑 'coffee' => 'c''o''f''f''e''e'랑 다름 |
     | L.index(x,start,end) | x값을 찾아 인덱스 반환, 없을 시 ValueError                   |
     | L.reverse()          | 순서를 반대로 뒤집음                                         |
     | L.sort(...)          | .sort()는 원본 변경 메소드, sorted(L)는 정렬된 리스트를 반환함수 |
     | L.count(x)           | 원하는 x 값의 개수를 반환                                    |

   - 튜플 메소드
     - 변경 불가, 리스트 메소드 중에 항목 변경말고 대부분 동일

2. 순서가 없는 데이터 구조

   - 셋, 딕셔너리

     ![image-20220203232456162](%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EA%B3%BC%EB%AA%A9%ED%8F%89%EA%B0%80%20%EC%A0%95%EB%A6%AC.assets/image-20220203232456162.png)

3. 얕은 복사 깊은 복사

- 할당 : 대입연산자(=)를 통한 복사는 해당 객체에 대한 객체 참조를 복사

  ```python
  origin = [1,2,3]
  copy = origin
  print(origin, copy) # => [1,2,3], [1,2,3]
  copy[0] = 'hello'
  print(origin, copy) # => ['hello',2,3] ['hello',2,3] 
  # 둘다바뀜 왜냐면 객체가 가르킨 값이 바뀐거니까, 값을 참조하는 모든 변수에 영향을 줌
  ```

- 얕은 복사 : slice 연산자를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사 (다른 주소)

  ```python
  a = [1,2,3]
  b = a[:]
  print(a,b)			# => [1,2,3], [1,2,3]
  b[0] = 5
  print(a,b)			# => [1,2,3], [5,2,3]
  # a,b가 각각 참조하는 객체리스트가 다름, 그러니까 원래는 그대로이고, copy 값만 바뀜
  ```

- 깊은 복사 :

  - 얕은 복사에서 주의사항 : 복사한 리스트의 원소가 주소를 참조할 경우

    ```python
    a = [1,2,['a','b']]
    b = a[:]
    b[2][0] = 0
    print(a,b) 		# => [1,2,[0,'b']], [1,2,[0,'b']]
    ```

     

8. 예외처리

   1. 디버깅

      - print문 활용
      - 개발환경(vscode, pycharm,IDE) 등에서 제공하는 기능 활용
        - breakpoint(디버그 모드), 변수 조회 등
      - 단순 파이썬 코드 경우 Python tutor 활용
      - 뇌컴파일, 눈디버깅

   2. 에러와예외

      - 문법 에러 : 신텍스 에러
        - invaild syntax, assign to literal, Eid of Line, End of File
      - 예외 - NameError, TypeError 등등
        - ZeroDivisionError : 0으로 나눌 수 없음
        - NameError :변수의 이름이 없음 / 이름에 오타가 있거나, 잘못된 명령을 할 때
        - TypeError : 타입불일치 , argument 갯수 초과
        - ValueError : 타입은 올바르나, 값이 적절하지 않을 때
        - IndexError : 인덱스가 존재하지 않거나, 범위를 벗어났을 떄
        - IndentationError : 들여쓰기 잘못되었을 때

   3. 예외 처리 : try-except 을 이용하여 예외 처리할 수 있음

      try : 코드를 실행함

      except as: try에서 예외 발생 시 실행함 , as는 별명

      else : try에서 예외 발생하지 않으면 실행함

      finally : 예외 발생 여부와 관계없이 실행함

   4. 예외 발생 시키기

      - raise<표현식>(메세지)
      - assert<표현식>,<메세지> : 상태를 검증하는데 사용, 디버깅 용도



 10. OOP

     > 파이썬은 모두 객체로 이루어져 있다.
     >
     > 객체는 숫자,문자,리스트 등으로 이루어진 모든 것이며, 특정 타입의 인스턴스이다.
     >
     > 객체는 속성(어떤 데이터를 가지는가)과 메서드(어떤 행위를 할 수 있는가)로 이루어져있다.

     1. OOP기초

        - 객체 지향 프로그래밍은 : 프로그램의 여러 개의 독립된 객체들과 객체들간의 상호작용으로 ㅍ파악하는 프로그래밍 방법이다. 속성과 기능을 분리한 추상화된 구조라고 볼 수 있다.

        - 절차 지향 프로그래밍은 데이터와 함수로 인한 변화를 이용한 프로그래밍 방법이다.

        - 장점 :  1.프로그램을 유연하고 변경이 용이하게 만들기 좋다.

          ​			2.소프트웨어 개발과 보수를 간편하게 한다.

          ​			3.보다 직관적인 코드 분석을 할 수 있다.

          

     2. 인스턴스 : 하나하나의 실체

        - 인스턴스 변수 : 인스턴스의 식별자, 각 인스턴스의 고유한 변수

          - 생성자 메소드에서 self.name = name  
            - name이란 인스턴스를 self.name이란 인스턴스변수에 할당
          - instance가 생성되었다면 instance.name으로 접근 및 할당

        - 인스턴스 메소드 : 인스턴스 변수가 클래스 내부에 정의된 메소드를 사용

          - __ init __ : 생성자 메소드
          - __ del __ : 소멸자 메소드
          - __ str __ :출력 메소드
          - __ gt __ : 부등호 연산자 메소드

          

     3. 클래스 : 객체들의 분류

        - 클래스 변수 : 클래스 내부에 정의한 변수
          - classname.name 으로 접근 및 할당
        - 인스턴스 변수가 정의되어 있지 않다면 클래스 변수가 출력됨

     4. 메소드 : 특정 타입의 객체가 어떤 행위를 하는지에 대한 내용

        - 속성 : 특정 타입의 객체가 어떠한 데이터 타입을 가지고 있는지에 대한 내용
        - @인스턴스 메소드 : 인스턴스 메소드가 클래스 상태를 수정 가능
          - 클래스 자체에서 인스턴스 메소드를 호출할 수 없음
        - 클래스 메소드 : 클래스 메소드가 객체 인스턴스 상태를 수정 불가
        - @스태틱 메소드 : 객체 상태나 클래스 상태 수정 불가

        

### 객체지향의 핵심 4가지

1. 추상화 : 세부적인 내용은 감추고 필수적인 것만 표현한다.

2. 상속 : 부모 클래스의 모든 속성이 자식 클래스에 상속되므로 코드의 용이성이 높아진다.
   -  자식 클래스의 인스턴스는 부모 클래스의 메서드를 호출 할 수 있음
   - super().__ init __(name, age ,, ) : 중복하지 않음

3. 다형성 : 동일한 메서드가 클래스에 따라 다르게 행동할 수 있다.

4. 캡슐화 : 객체의 일부 구현에 대해 외부의 직접적인 엑세스를 차단해준다.
   - pubilc member : 어디서나 호출가능
   - protected member : 언더바 1개 # 본 클래스 내부나 자식 클래스에서만 호출한다.
   - private member : 언더바 2개 # 본 클래스 내부에서만 사용하고, 직접적으로 접근 불가