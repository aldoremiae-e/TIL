# 완전검색 & 그리디



## 반복구조

### 반복을 이용한 선택정렬

- 선택정렬 : 구간의 시작을 i라고 할때 어딘가에서 가장 작은 것을 앞에다 가져다 놓고, 다음 구간은 i+1부터!

### 재귀적으로 선택정렬

장점 : 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다.

단점 : 더 많은 메모리와 연산을 필요로 한다. 즉, 입력 값 n이 커질수록 비효율적이다.



|              | 재귀                                    | 반복                 |
| ------------ | --------------------------------------- | -------------------- |
| 종료         | 재귀 함수 호출이 종료되는 베이스 케이스 | 반복문의 종료 조건   |
| 수행시간     | 느림                                    | 빠름                 |
| 메모리공간   | 많이 사용                               | 적게 사용            |
| 소스코드길이 | 짧고 간격                               | 길다                 |
| 소스코드형태 | 선택구조(if)                            | 반복구조(for, while) |
| 무한반복시   | 스택 오버플로우                         | CPU를 반복해서 점유  |



### 팩토리얼 재귀 함수의 호출



## 완전검색기법

> 오래걸리지만 해답을 찾을 수 있는 확률이 높다.

- 순열 조합 부분집합과 같은 조합적 문제들에 대한 `brute-force`이다.



## 조합적 문제



### 1. 순열 : nPr : n(n-1)(n-2)...(n-r)

```python
for i in 1->3:
    for j in 1->3:
        if j != i:
            for k in 1->3:
                if k != i and k != j:
                    print(i, j, k)
```

재귀를 통한 순열

```python
# k개 중에 k개를 순서대로 나열하는 방법
def f(n, k):    # 순열
   if n == k:
       print(p)
   else:
       for i in range(k):      # used 사용하지 않은 숫자 검색
            if used[i] == 0:    # 앞에서 사용하지 않은 숫자인 경우
                used[i] = 1     # 사용함으로 표시
                p[n] = a[i]
                f(n+1, k)
                used[i] = 0     #a[i]를 다른 위치에서 사용할 수 있도록 함

a = [1, 2, 3]
p = [0] * 3
used = [0] * 3
f(0, 3)
```

```python
# m개 중에 k개를 순서대로 나열하는 방법 (k < m)
def f(n, k, m):    # 순열    - m개 중에 k개를 뽑는 경우
   if n == k:   # k개를 고른 경우
       print(p)
   else:
       for i in range(m):      # used 사용하지 않은 숫자 검색
            if used[i] == 0:    # 앞에서 사용하지 않은 숫자인 경우
                used[i] = 1     # 사용함으로 표시
                p[n] = a[i]
                f(n+1, k, m)
                used[i] = 0     #a[i]를 다른 위치에서 사용할 수 있도록 함

a = [1, 2, 3, 4, 5]
p = [0] * 3
used = [0] * 5
f(0, 3, 5)
```



### 2. 부분집합

단순하게 만드는 방법

```python
for i in 0 -> 1:
    bit[0] = i
    for j in 0 -> 1:
        bit[1] = j
        for k in 0 ->1:
            bit[2] = k
            print(arr)
```



binary counting 을 통해 부분집합 만들기

- 원소 수에 해당하는 N개의 비트열 이용

- n번째 비트값이 1이면 n번째 원소가 포함되었다는 의미

  | 10진수 | 2진수 | {A,B,C} |
  | ------ | ----- | ------- |
  | 0      | 000   | -       |
  | 1      | 001   | A       |
  | 2      | 010   | B       |
  | 3      | 011   | A,B     |
  | 4      | 100   | C       |
  | 5      | 101   | A,C     |
  | 6      | 110   | B,C     |
  | 7      | 111   | A,B,C   |

   ```python
   arr =[3, 6, 7, 1, 5, 4]
   n = len(arr)
   
   for i in range(0, 1<<n):	#1<<n : 부분집합의 개수
       for j in range(0, n):
           if i & (1<<j):		#i의 j번째 비트가 1이면 j번째 원소 출력
               print(arr[j],end=' ')
       print()
   ```



### 3. 조합 : nCr

```python
# 크기 순으로 만드는 조합
arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

for i in range(8):
    for j in range(i+1,9):
        for k in range(j+1,10):
            print(arr[i], arr[j], arr[k])
```



재귀 호출을 이용한 조합 생성 알고리즘 ( 변형 가능!)

```python
def f(n, r, s, k):      # n개에서 r개를 고르는 조합, s는 선택구간의 시작, k 고른 개수
    if r == 0:
        print(comb)
    else:
        for i in range(s, n-r+1):     #n-r+k 선택할 수 있는 구간의 끝
            comb[k-r] = arr[i]
            f(n, r-1, i+1, k)
n = 10
r = 3
k = r
arr = [i for i in range(1, n+1)]
comb = [0] * r
f(n, r, 0, k)
```



 