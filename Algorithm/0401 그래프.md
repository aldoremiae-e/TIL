# 0401 그래프



## 그래프 기본

- 그래프 : 아이템들과 이들 사이의 관계

- 정점과 간선들의 집합으로 구성된 자료구조

- 유형 : 

  1. 방향

     - 무향 그래프

     - 유향 그래프

     - 가중치 그래프

     - 사이클 없는 방향 그래프

  2. 완전 그래프 <=> 부분 그래프

- 인접 : 두개의 정점에 간선이 연결되어 있다면 인접해있다.

  - 인접 행렬 : VxV 2차원 배열을 이용해서 간선 정보를 저장 / 배열의 배열
  - 인접 리스트 : 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
  - 간선의 배열 : 간선을 배열에 연속적으로 저장

1. 그래프 기법 : BFS, DFS

   

   <img src="C:/Users/bamxd/AppData/Roaming/Typora/typora-user-images/image-20220401125403064.png" alt="image-20220401125403064" style="zoom: 67%;" />

   ### DFS코드

   ```python
   #DFS
   def dfs(v, V):
       visited[v] = 1
       print(v, end=' ')
       for w in range(1, V+1):
           if adjM[v][w] == 1 and visited[w] == 0:
               dfs(w, V)
   
   def dfs2(v, V):
       stack = [v] # 스택생성 + 시작정점 push
       visited = [0] * (V+1)
       visited[v] = 1  # 스택에 들어간애는 방문표시
   
       while stack:
           v = stack.pop()
           print(v, end=' ')
           for w in range(1, V+1):
               if adjM[v][w] == 1 and visited[w] == 0: # 인접하고 미방문
                   stack.append(w)     # 갈림길 목록 - 나로부터 제일 가까운걸 꺼낼거야
                   visited[w] = 1
   
   def dfs3(v, V):
       stack = [v] # 스택생성 + 시작정점 push
       visited = [0] * (V+1)
   
       while stack:
           v = stack.pop()
           if visited[v] == 0:
               print(v, end=' ')
               visited[v] = 1
           for w in range(1, V+1):
               if adjM[v][w] == 1 and visited[w] == 0: # 인접하고 미방문
                   stack.append(w)     # 갈림길 목록 - 나로부터 제일 가까운걸 꺼낼거야
   
   
   V, E = map(int, input().split())
   arr = list(map(int, input().split()))
   adjM = [[0] * (V+1) for _ in range(V+1)]    # 인접행렬
   
   for i in range(E):
       n1, n2 = arr[i*2], arr[i*2+1]   #n1: 출발 n2:도착
       adjM[n1][n2] = 1        # 방향성인 경우, 인접이면 1이다
       adjM[n2][n1] = 1        # 무향성인 경우
   
   #visited = [0] * (V+1)
   #dfs(1, V)
   
   #dfs2(1, V)
   #dfs3(1, V)
   bfs(1, V)
   ```

   ### BFS 코드

   ```python
   def bfs(s, V):
       q = []
       visited = [0] * (V+1)
       q.append(s)
       visited[s] = 1
       while q:
           v = q.pop(0)
           print(v, end=' ')
           for w in range(1, V+1):
               if adjM[v][w] == 1 and visited[w] == 0:
                   q.append(w)
                   visited[w] = visited[v] + 1
       return
   def bfs2(s, V):
       q = []  # 큐 생성
       visited = [0] * (V+1)   #방문
       q.append(s) # 시작점 인큐
       visited[s] = 1  #시작점 인큐방문
       while q:
           v = q.pop(0)
           print(v, end=' ')
           for w in adjL[v]:
               if visited[w] == 0:
                   q.append(w)
                   visited[w] = visited[v] + 1
   
   V, E = map(int, input().split())
   arr = list(map(int, input().split()))
   adjM = [[0] * (V+1) for _ in range(V+1)]    # 인접행렬
   adjL = [[] for _ in range(V+1)]     #인접리스트
   for i in range(E):
       n1, n2 = arr[i*2], arr[i*2+1]   #n1: 출발 n2:도착
       adjM[n1][n2] = 1        # 방향성인 경우, 인접이면 1이다
       adjM[n2][n1] = 1        # 무향성인 경우
   
   for i in range(E):
       n1, n2 = arr[i*2], arr[i*2+1]
       adjL[n1].append(n2)
       adjL[n2].append(n1)
   bfs(1, V)
   print()
   bfs2(1, V)
   ```

   

   ```
   7 8
   1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
   ```

   - 방향성이 없는 그래프일 때 **` adjM[n2][n1] = 1 `** 적어줌
     - dfs : `1 2 4 6 5 7 3 `
     - dfs2: `1 3 7 6 5 4 2 `
     - dfs3: `1 3 7 6 5 2 4 `
     - bfs : `1 2 3 4 5 7 6 `
     - bfs2  : `1 2 3 4 5 7 6`
   - 방향성이 있는  그래프일 때 **` adjM[n2][n1] = 1 `** 주석처리
     - dfs : `1 2 4 6 7 5 3 `
     - dfs2 : `1 3 7 2 5 6 4 `
     - dfs3 : `1 3 7 2 5 6 4 `

   

## 2. 상호배타 집합의 자료구조

## 3. 최소 신장 트리(MSP)

1. Prim
   - 첫번째 방법
   - 두번째 방법

2. KRUSKAL

3. 최단경로

   - 다익스트라 알고리즘

     > 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식

     - 음의 가중치를 허용하지 않음

     ```python
     def Dijkstra(s, A, D):
         U = [0] * (V+1)	#visited
         U[s] = 1	
         
         for i in range(V+1):
             D[i] = A[s][i]
             
         for _ in range(V):
             D[w]가 최소인 정점 w ∈ V-U 선택
             U = U∪{w}
             for w에 인접한 모든 정점 v:
                 D[v] = min(D[v], D[w]+A[w][v])
     ```

     

   - 벨만포드 알고리즘

     - 음의 가중치 허용