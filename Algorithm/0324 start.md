# SW문제해결

### 문제 해결 과정

1. 문제를 읽는다
2. 문제를 이해한다
3. 용어를 재정의한다
4. 고려사항을 정리한다
5. 문제해결방안을 마련한다
6. 계획에 오류는 없는지 확인한다.



### 문제 해결 전략

체계적 접근 필요

1. 비슷한 문제를 풀어분적있는가
2. 단순한 방법에서 시작할 수 있을까?
3. 문제를 단순화 할 수 있을까? 그림 수식 이용
4. 문제를 분해할 수 있을까?
5. 뒤에서부터 사용할 수 있을까?
6. 특정 형태의 답만을 사용할 수 있을까?



### 비트연산

`1<<n` : 곱한 결과

- 2^n의 값을 가짐

- 원소가 n개일 경우의 모든 부분집합의 수를 의미
- Power set(모든 부분 집합)
  - 공집합과 자기자신을 포함한 모든 부분집합
  - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합 수 계산가능



`i&(1<<j)` : 특정 위치의 비트 값 (i의 j 번째 비트) 이 1인지 0인지 판별할 때 사용

```python
# 8비트의 문자형 변수에 저장된 비트 값들을 출력하는 함수
def Bbit_print(i):
    output = ""
    for j in range(7, -1, -1):
        output += "1" if i & (1 << j) else "0"
    print(output, end=' ')
```



`endian` : 컴퓨터의 메모리와 같은 일차원의 공간에 여러 개의 연속된 대상을 배열하는 방법

| 종류                                | 0x1234 | 0x12345678  |
| ----------------------------------- | ------ | ----------- |
| 빅 엔디안 (큰 단위가 앞에 나옴)     | 12 34  | 12 34 56 78 |
| 리틀 엔디안 (작은 단위가 앞에 나옴) | 34 12  | 78 56 34 12 |

```python
# 빅 엔디안
h2b = ['0000', '0001', '0010', '0011', '0100', '0101', '0110',  '0111', '1000',
       '1001', '1010', '1011', '1100', '1101', '1110', '1111']
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    arr = list(input())
s = ''
    for i in range(N):
        s += h2b[arr[i]]
    print(s)
    print(f'#{tc}', end=' ')
    for i in range(N*4 // 7):
        # int(value, base)
        print(int(s[i*7:i*7+7],2), end=' ')
    print()
```

