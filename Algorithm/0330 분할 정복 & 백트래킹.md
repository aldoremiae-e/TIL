# 0330 분할 정복 & 백트래킹

## 1. 분할정복

- 설계 전략 (Top-down approach)
  1. 분할 : 해결할 문제를 여러 개의 작은 부분으로 나눈다
  2. 정복 : 나눈 작은 문제를 각각 해결한다
  3. 통합 : 해결된 해답을 모은다
- 반복 알고리즘 : O(n)
- 시간 복잡도 : O(logn)

### 퀵 정렬

> 주어진 배열을 두개로 분할하고, 각각 정렬
>
> 두 부분으로 분할할 때, 기준 아이템(pivot) 중심으로 나눈다
>
> 퀵 정렬은 병합 후처리가 필요하지 않다

```python
def quick(arr, l, r):
    if l < r:
        s = partition(arr, l, r)	#피벗 위치를 반환
        quick(arr, l , s-1)
        quick(arr, s+1, r)
```

```python
def partition1(arr, l, r):		#피벗 위치 찾기1 - Hoare partition
    p = arr[l]	# 초기값 맨 앞에꺼
    i, j = l, r		#맨 앞과 맨 뒤
    while i <= j:	# 교차하기 전까지 반복
        while i <= j and arr[i] <= p:	#기준값보다 큰 숫자를 찾아
            i += 1
        while i <= j and arr[j] >= p:	#기준값보다 작은 숫자를 찾아
            j -= 1
        if i < j:	#두개가 교차되지 않았을 떄, 두개의 자리를 바꿔
            swap(arr[i],arr[j])
            
    swap(arr[l],arr[j])		#피벗값보다 작은 것들이 왼쪽으로 갈 수 있도록
    return j		#피벗의 위치를 고정시키고 반환
```

```python
def partition2(arr, p, r):		#피벗 위치 찾기2 - Lomuto partition
    x = arr[r]	# 초기값 맨 뒤꺼
    i = p-1	# 맨 앞거 보다 앞
    
    for j in range(p, r-1):
        if a[j] <= x:	# 기준값보다 작으면
            i += 1	# i가 j를 따라가
        	swap(arr[i], arr[j])	#기준값보다 크면 
    swap(a[i+1],a[r])	# 피벗값보다 작은 것들이 왼쪽으로 갈 수 있도록
    return i+1
```

- Hoare 이 Lomuto보다 빠르다

### 병합 정렬

> 여러개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
>
> top-down 방식
>
> 시간 복잡도 : O(nlogn)

```python
def merge(left, right):		#병합
    result = []
    while len(left) > 0 or len(right) > 0:
        if len(left) and len(right) > 0:
            if first(left) <= first(right):		#왼쪽 첫번째칸, 오른쪽 첫번째칸 비교
                result.append(left.pop(0))
            else:
                result.append(right.pop(0))
        elif len(left) > 0:
            result.append(left.pop(0))
        elif len(right) > 0:
            result.append(right.pop(0))
    return result

def merge_sort(lst):		#분할 - 정렬
    if len(lst) == 1:
        return lst
    left, right = [], []
    middle = lem(lst) //2
    for x in range(0,middle):	# 왼쪽 분할
        add x to left
    for x in range(middle,len(lst)):	# 오른쪽 분할
        add x to right
    
    left.sort()		# 정렬
    right.sort()	# 정렬
    
    return merge(left, right)
```



### 이진 검색(Binary Search)

```python
def binary(n, arr, key):
    low = 0
    high = n - 1
    
    while low <= high:
        mid = low + (high - low) // 2
        if s[mid] == key:
            return mid
        elif s[mid] > key:
            high = mid - 1
        else:
            low = mid + 1
    return -1
```



## 2. 백트래킹

- promising하지 않다고 결정되면 그 노드의 부모로 backtracking 다음 자식 노드로 감

- 백트래킹과 DFS(깊이 우선 탐색) 차이
  - 깊이 우선 탐색은 모든 경로를 추적하지만, 백트래킹은 불필요한 경로를 차단
  - 깊이 우선 탐색은 경우의 수가 너무 많을 때는 불가
  - 백트래킹 알고리즘을 적용하여 경우의 수가 줄어들지만, 최악의 경우 지수함수 시간을 요하므로 처리 불가능 = > 백트래킹을 한다고 항상 되는 것이 아니다.

```python
def check(node):
    if promising(node):
        if there is a solution at node:
            solution
        else:
            for each child u of node:
                check(u)
```

- 상태공간트리를 구축하여 문제를 해결



## 3. 트리

- 삽입연산
  1. 먼저 탐색 연산을 수행
     - 삽입할 원소와 같은 원소가 트리에 삽입할 수 없다. 같은 원소가 트리에 있는지 탐색!
     - 탐색실패가 결정되는 위치 : 삽입위치
  2. 탐색 실패한 위치에 원소를 삽입
- 삭제연산
  - 삭제할 노드가 리프 노드 : 차수 0인 경우 - 그냥 삭제
  - 삭제할 노드가 리프 노드가 아닌 경우 : 
    - 차수가 1인 경우 - 삭제되면 , 하위 노드들이 부모 노드로 올라옴
    - 차수가 2인 경우(루트 노드) - 삭제 되면, 후보를 찾아 이동



- heap

  1. 최대 힙
     - 키 값이 가장 큰 노드를 찾기 위한 `완전 이진 트리`
     - 부모 노드의 키 값 > 자식 노드의 키 값
     - 루트 노드 : 키 값이 가장 큼
  2. 최소 힙
     - 키 값이 가장 작은 노드를 찾기 위한 `완전 이진 트리`
     - 부모 노드의 키 값 < 자식 노드의 키 값
     - 루트 노드 : 키 값이 가장 작음

  3. 힙의 활용 : 특별한 큐의 구현, 정렬